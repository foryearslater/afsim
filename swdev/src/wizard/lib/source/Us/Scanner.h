// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// Copyright 2003-2015 The Boeing Company. All rights reserved.
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************

// NOTE: DO NOT HAND-EDIT THIS FILE! It is generated by the COCO/R compiler generator.
//       See wizard/lib/source/Us/AAA_README.TXT.

#if !defined(Us_COCO_SCANNER_H__)
#define Us_COCO_SCANNER_H__

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <limits.h>

// io.h and fcntl are used to ensure binary read from streams on windows
#if _MSC_VER >= 1300
#include <fcntl.h>
#include <io.h>
#endif

#define COCO_USE_WCHAR_T 0
#if COCO_USE_WCHAR_T
struct COCO_Str
{
   typedef wchar_t       char_type;
   static wchar_t*       ncpy(wchar_t* dest, const wchar_t* src, size_t n) { return wcsncpy(dest, src, n); }
   static wchar_t*       cpy(wchar_t* dest, const wchar_t* src) { return wcscpy(dest, src); }
   static int            len(const wchar_t* s) { return (int)wcslen(s); }
   static int            cmp(const wchar_t* s1, const wchar_t* s2) { return wcscmp(s1, s2); }
   static const wchar_t* rchr(const wchar_t* wcs, wchar_t wc) { return wcsrchr(wcs, wc); }
   static wchar_t*       rchr(wchar_t* wcs, wchar_t wc) { return wcsrchr(wcs, wc); }
   static const wchar_t* chr(const wchar_t* wcs, wchar_t wc) { return wcschr(wcs, wc); }
   static wchar_t*       chr(wchar_t* wcs, wchar_t wc) { return wcschr(wcs, wc); }
};
#if _MSC_VER >= 1400
#define coco_sprintf swprintf_s
#elif _MSC_VER >= 1300
#define coco_sprintf _snwprintf
#elif defined __MINGW32__
#define coco_sprintf _snwprintf
#else
// assume every other compiler knows swprintf
#define coco_sprintf swprintf
#endif
#define COCO_STR(X) L##X
#define coco_printf wprintf
#else // NOT use wchar_t
struct COCO_Str
{
   typedef char       char_type;
   static char*       ncpy(char* dest, const char* src, size_t n) { return strncpy(dest, src, n); }
   static char*       cpy(char* dest, const char* src) { return strcpy(dest, src); }
   static int         len(const char* s) { return (int)strlen(s); }
   static int         cmp(const char* s1, const char* s2) { return strcmp(s1, s2); }
   static const char* rchr(const char* wcs, char wc) { return strrchr(wcs, wc); }
   static char*       rchr(char* wcs, char wc) { return strrchr(wcs, wc); }
   static const char* chr(const char* wcs, char wc) { return strchr(wcs, wc); }
   static char*       chr(char* wcs, char wc) { return strchr(wcs, wc); }
};

#define coco_sprintf sprintf
#define coco_snprintf snprintf
#define COCO_STR(X) X
#define coco_printf printf
#endif

using cocochar_t = COCO_Str::char_type;

#define COCO_WCHAR_MAX 65535
#define COCO_MIN_BUFFER_LENGTH 1024
#define COCO_MAX_BUFFER_LENGTH (64 * COCO_MIN_BUFFER_LENGTH)
#define COCO_HEAP_BLOCK_SIZE (64 * 1024)
#define COCO_CPP_NAMESPACE_SEPARATOR COCO_STR(':')

namespace Us
{

// string handling, wide character
cocochar_t*  coco_string_create(const cocochar_t* value);
cocochar_t*  coco_string_create(const cocochar_t* value, int startIndex);
cocochar_t*  coco_string_create(const cocochar_t* value, int startIndex, int length);
cocochar_t*  coco_string_create_upper(const cocochar_t* data);
cocochar_t*  coco_string_create_lower(const cocochar_t* data);
cocochar_t*  coco_string_create_lower(const cocochar_t* data, int startIndex, int dataLen);
cocochar_t*  coco_string_create_append(const cocochar_t* data1, const cocochar_t* data2);
cocochar_t*  coco_string_create_append(const cocochar_t* data, const cocochar_t value);
void         coco_string_delete(cocochar_t*& data);
int          coco_string_length(const cocochar_t* data);
bool         coco_string_endswith(const cocochar_t* data, const cocochar_t* value);
int          coco_string_indexof(const cocochar_t* data, const cocochar_t value);
int          coco_string_lastindexof(const cocochar_t* data, const cocochar_t value);
void         coco_string_merge(cocochar_t*& data, const cocochar_t* value);
bool         coco_string_equal(const cocochar_t* data1, const cocochar_t* data2);
int          coco_string_compareto(const cocochar_t* data1, const cocochar_t* data2);
unsigned int coco_string_hash(const cocochar_t* data);

// string handling, ascii character
#if COCO_USE_WCHAR_T
cocochar_t* coco_string_create(const char* value);
void        coco_string_delete(char*& data);
#endif
char* coco_string_create_char(const cocochar_t* value);

class Token
{
public:
   Token();
   virtual ~Token();

   int         kind{0};       // token kind
   int         pos{0};        // token position in bytes in the source text (starting at 0)
   int         charPos{0};    // token position in characters in the source text (starting at 0)
   int         col{0};        // token column (starting at 1)
   int         line{0};       // token line (starting at 1)
   cocochar_t* val{nullptr};  // token value
   Token*      next{nullptr}; // ML 2005-03-11 Peek tokens are kept in linked list
   int         len{0};
};
#define COCO_USE_INLINE_BUFFER 1
#if COCO_USE_INLINE_BUFFER
// Support for utf8 increases parse time, particularly because Read() is virtual.
// This is an alternate implementation of Buffer which does not have virtual methods,
// and only supports in-memory multi-byte files
class Buffer
{
public:
   static const int EoF = COCO_WCHAR_MAX + 1;

   Buffer(const Buffer& aSrc) = delete;
   Buffer& operator=(const Buffer& aRhs) = delete;

   Buffer(const unsigned char* buf, int len)
   {
      this->buf = new unsigned char[len];
      memcpy(this->buf, buf, len * sizeof(unsigned char));
      bufCapacity = bufLen = len;
      fileLen              = len;
      bufPos               = 0;
   }
   Buffer(Buffer* b);
   ~Buffer()
   {
      if (buf != nullptr)
      {
         delete[] buf;
         buf = nullptr;
      }
   }

   void Close() {}
   int  Read()
   {
      if (bufPos < bufLen)
      {
         return buf[bufPos++];
      }
      else
      {
         return EoF;
      }
   }
   int Peek()
   {
      int curPos = GetPos();
      int ch     = Read();
      SetPos(curPos);
      return ch;
   }

   // beg .. begin, zero-based, inclusive, in byte
   // end .. end, zero-based, exclusive, in byte
   cocochar_t* GetString(int beg, int end)
   {
      int         len    = 0;
      cocochar_t* buffer = new cocochar_t[end - beg];
      int         oldPos = GetPos();
      SetPos(beg);
      while (GetPos() < end)
         buffer[len++] = (cocochar_t)Read();
      SetPos(oldPos);
      cocochar_t* res = coco_string_create(buffer, 0, len);
      coco_string_delete(buffer);
      return res;
   }
   int  GetPos() { return bufPos; }
   void SetPos(int value)
   {
      if ((value < 0) || (value > fileLen))
      {
         coco_printf(COCO_STR("--- buffer out of bounds access, position: %d\n"), value);
         exit(1);
      }
      if ((value >= 0) && (value < (bufLen))) // already in buffer
      {
         bufPos = value;
      }
      else
      {
         bufPos = fileLen; // make Pos return fileLen
      }
   }

private:
   unsigned char* buf;
   int            bufCapacity; // capacity of buf
   int            bufLen;      // length of buffer
   int            fileLen;     // length of input stream (may change if the stream is no file)
   int            bufPos;      // current position in buffer
};

#else
class Buffer
{
   // This Buffer supports the following cases:
   // 1) seekable stream (file)
   //    a) whole stream in buffer
   //    b) part of stream in buffer
   // 2) non seekable stream (network, console)
public:
   static const int EoF = COCO_WCHAR_MAX + 1;

   Buffer(const Buffer& aSrc) = delete;
   Buffer& operator=(const Buffer& aRhs) = delete;

   Buffer(FILE* s, bool isUserStream);
   Buffer(const unsigned char* buf, int len);
   Buffer(Buffer* b);
   virtual ~Buffer();

   virtual void        Close();
   virtual int         Read();
   virtual int         Peek();
   virtual cocochar_t* GetString(int beg, int end);
   virtual int         GetPos();
   virtual void        SetPos(int value);

private:
   unsigned char* buf;          // input buffer
   int            bufCapacity;  // capacity of buf
   int            bufStart;     // position of first byte in buffer relative to input stream
   int            bufLen;       // length of buffer
   int            fileLen;      // length of input stream (may change if the stream is no file)
   int            bufPos;       // current position in buffer
   FILE*          stream;       // input stream (seekable)
   bool           isUserStream; // was the stream opened by the user?

   int  ReadNextStreamChunk();
   bool CanSeek(); // true if stream can be seeked otherwise false
};

class UTF8Buffer : public Buffer
{
public:
   UTF8Buffer(Buffer* b)
      : Buffer(b){};
   virtual int Read();
};
#endif

//-----------------------------------------------------------------------------------
// StartStates  -- maps characters to start states of tokens
//-----------------------------------------------------------------------------------
class StartStates
{
public:
   StartStates()
   {
      tab = new Elem*[128];
      memset(tab, 0, 128 * sizeof(Elem*));
   }
   virtual ~StartStates()
   {
      for (int i = 0; i < 128; ++i)
      {
         Elem* e = tab[i];
         while (e != nullptr)
         {
            Elem* next = e->next;
            delete e;
            e = next;
         }
      }
      delete[] tab;
   }

   StartStates(const StartStates& aSrc) = delete;
   StartStates& operator=(const StartStates& aRhs) = delete;

   void set(int key, int val)
   {
      Elem* e = new Elem(key, val);
      int   k = ((unsigned int)key) % 128;
      e->next = tab[k];
      tab[k]  = e;
   }

   int state(int key)
   {
      Elem* e = tab[((unsigned int)key) % 128];
      while (e != nullptr && e->key != key)
         e = e->next;
      return e == nullptr ? 0 : e->val;
   }

private:
   class Elem
   {
   public:
      int   key, val;
      Elem* next;
      Elem(int key, int val)
      {
         this->key = key;
         this->val = val;
         next      = nullptr;
      }
   };

   Elem** tab;
};

//-------------------------------------------------------------------------------------------
// KeywordMap  -- maps strings to integers (identifiers to keyword kinds)
//-------------------------------------------------------------------------------------------
class KeywordMap
{
public:
   KeywordMap()
   {
      tab = new Elem*[128];
      memset(tab, 0, 128 * sizeof(Elem*));
   }
   virtual ~KeywordMap()
   {
      for (int i = 0; i < 128; ++i)
      {
         Elem* e = tab[i];
         while (e != nullptr)
         {
            Elem* next = e->next;
            delete e;
            e = next;
         }
      }
      delete[] tab;
   }

   KeywordMap(const KeywordMap& aSrc) = delete;
   KeywordMap& operator=(const KeywordMap& aRhs) = delete;

   void set(const cocochar_t* key, int val)
   {
      Elem*        e = new Elem(key, val);
      unsigned int k = coco_string_hash(key) % 128;
      e->next        = tab[k];
      tab[k]         = e;
   }

   int get(const cocochar_t* key, int defaultVal)
   {
      Elem* e = tab[coco_string_hash(key) % 128];
      while (e != nullptr && !coco_string_equal(e->key, key))
         e = e->next;
      return e == nullptr ? defaultVal : e->val;
   }

private:
   class Elem
   {
   public:
      cocochar_t* key;
      int         val;
      Elem*       next;
      Elem(const cocochar_t* key, int val)
      {
         this->key = coco_string_create(key);
         this->val = val;
         next      = nullptr;
      }
      virtual ~Elem() { coco_string_delete(key); }
   };

   Elem** tab;
};

class Scanner
{
public:
   Scanner(const unsigned char* buf, int len);
#if !COCO_USE_INLINE_BUFFER
   Scanner(const cocochar_t* fileName);
   Scanner(FILE* s);
#endif
   virtual ~Scanner();

   Scanner(const Scanner& aSrc) = delete;
   Scanner& operator=(const Scanner& aRhs) = delete;

   Token* Scan();
   Token* Peek();
   void   ResetPeek();

   void (*NewTokCb)(Token*, void*);
   void* mNewTokenDataPtr;

   Buffer* buffer{nullptr}; // scanner buffer

private:
   void*  firstHeap;
   void*  heap;
   void*  heapTop;
   void** heapEnd;

   unsigned char EOL;
   int           eofSym{0};
   int           noSym{0};
   int           maxT{0};
   StartStates   start;
   KeywordMap    keywords;

   Token*      t{nullptr};    // current token
   cocochar_t* tval{nullptr}; // text of current token
   int         tvalLength{0}; // length of text of current token
   int         tlen{0};       // length of current token

   Token* tokens{nullptr}; // list of tokens already peeked (first token is a dummy)
   Token* pt{nullptr};     // current peek token

   int ch{0}; // current input character
              // ***Casing Begin

   // ***Casing End
   int pos{0};     // byte position of current character
   int charPos{0}; // position by unicode characters starting with 0
   int line{0};    // line number of current character
   int col{0};     // column number of current character
   int oldEols{0}; // EOLs that appeared in a comment;

   void   CreateHeapBlock();
   Token* CreateToken();
   void   AppendVal(Token* t);
   void   SetScannerBehindT();

   void   Init();
   void   NextCh();
   void   AddCh();
   Token* NextToken();

   // ***Comments Begin
   bool Comment0();
   bool Comment1();
   bool Comment2();

   // ***Comments End

}; // end Scanner

} // namespace Us

#endif
