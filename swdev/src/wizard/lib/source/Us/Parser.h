// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// Copyright 2003-2015 The Boeing Company. All rights reserved.
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************

// NOTE: DO NOT HAND-EDIT THIS FILE! It is generated by the COCO/R compiler generator.
//       See wizard/lib/source/Us/AAA_README.TXT.

#if !defined(Us_COCO_PARSER_H__)
#define Us_COCO_PARSER_H__

#include "Scanner.h"
#include "UsCtx.hpp"
#include "UsSymbolTable.hpp"

namespace Us
{

class Errors
{
public:
   int count{0}; // number of errors detected

   Errors()          = default;
   virtual ~Errors() = default;

   static char* GetStaticError(int aId);

   virtual void SynErr(Token* tok, int n);
   virtual void Error(Token* tok, const cocochar_t* s);
   virtual void Warning(Token* tok, const cocochar_t* s);
   virtual void Warning(const cocochar_t* s);
   virtual void Exception(const cocochar_t* s);

}; // Errors

class Parser
{
public:
   // ***Constants Header Begin
   enum
   {
      _EOF            = 0,
      _ident          = 1,
      _number         = 2,
      _real_number    = 3,
      _string_literal = 4,
      _char_literal   = 5,
      _dot            = 6,
      _semicolon      = 7,
      _lparen         = 8,
      _rparen         = 9,
      _assign         = 10,
      _eq             = 11,
      _ne             = 12,
      _ge             = 13,
      _le             = 14,
      _plus           = 15,
      _minus          = 16,
      _and            = 17,
      _or             = 18,
      _rbrace         = 19,
      _comma          = 20,
      _plus_assign    = 21,
      _minus_assign   = 22,
      _times_assign   = 23,
      _div_assign     = 24,
      _r_arrow        = 25,
      _do             = 26,
      _if             = 27,
      _for            = 28,
      _foreach        = 29,
      _in             = 30,
      _else           = 31,
      _while          = 32,
      _break          = 33,
      _continue       = 34,
      _return         = 35,
      _null           = 36,
      _null2          = 37,
      _true           = 38,
      _false          = 39,
      _string         = 40,
      _int            = 41,
      _double         = 42,
      _char           = 43,
      _bool           = 44,
      _global         = 45,
      _static         = 46,
      _extern         = 47,
      _ppvar          = 59,
      _ppvarEnd       = 60
   };
   int maxT;

   // ***Constants Header End

   // ***Declarations Begin - This section is a direct copy from .atg file
   using Cx      = Us::UsCtx;
   using Ty      = UsType;
   using Fn      = UsFunction;
   using Val     = Us::UsVal;
   using ValList = Us::UsValList;
   using Sy      = UsSymbol;

   Cx* mRootCx;

   bool IsAssignment()
   {
      if (la->kind != _ident)
         return false;
      Token* next = mScannerPtr->Peek();
      switch (next->kind)
      {
      case _assign:
      case _plus_assign:
      case _minus_assign:
      case _times_assign:
      case _div_assign:
         return true;
      default:
         return false;
      }
   }

   // Look for '(' 'TYPE' ~('.')
   bool IsCast(Cx& c)
   {
      bool   isCast = false;
      Token* next   = mScannerPtr->Peek();
      if (la->kind == _lparen && IsType(c, next))
      {
         isCast          = true;
         Token* nextNext = mScannerPtr->Peek();
         if (nextNext->kind == _dot)
            isCast = false;
      }
      mScannerPtr->ResetPeek();
      return isCast;
   }

   bool IsInitializerEntry()
   {
      if (la->kind == _comma)
      {
         Token* next = mScannerPtr->Peek();
         return next->kind != _rbrace;
      }
      return false;
   }

   // Determine if the lookahead token is the name of a visible user-defined script or a class method call
   // using an implied class reference such as '__BUILTIN__' or 'this'.
   bool IsScript(Cx& c)
   {
      UsVal v        = c.Search(la);
      bool  isScript = false;
      if (v.IsScript())
      {
         // Call to user-defined script.
         isScript = true;
      }
      else if (v.IsAppMethod())
      {
         // Call to a class method using an implied class reference.
         isScript = true;
      }
      return isScript;
   }

   // Determine if the supplied token is a registered type
   bool IsType(Cx& c, Token* tok) { return c.qType(tok) != nullptr; }

   // Determine if the lookahead token is a registered type
   bool IsType(Cx& c) { return c.qType(la) != nullptr; }

   bool IsVarDecl(Cx& c)
   {
      if (la->kind == _global || la->kind == _static || la->kind == _extern)
         return true;
      if (IsType(c))
      {
         Token* next = mScannerPtr->Peek();
         return !(next->kind == _dot || next->kind == _lparen);
      }
      return false;
   }

   void EOF_Token() { mRootCx->HitEOF(); }

   // ***Declarations End

   // Constructor and destructor
   explicit Parser(Scanner* aScannerPtr);
   Parser(const Parser& aSrc) = delete;
   Parser& operator=(const Parser& aRhs) = delete;
   virtual ~Parser();

   void InitParse();
   void Parse();

   void SemErr(const cocochar_t* msg);

   Scanner* mScannerPtr{nullptr}; // the scanner of this parser
   Errors*  mErrorsPtr{nullptr};  // error message stream

   // Not following standard in order to keep actions brief
   Token* t{nullptr};  // last recognized token
   Token* la{nullptr}; // lookahead token; not yet parsed

   // ***Production Header Begin
   void Script();
   void func_def(Cx& c);
   void basic_type();
   void type(Cx& c, Ty*& ty);
   void identifier(Cx& c, Val& v);
   void static_exp(Cx& c, Val& v);
   void arg_list(Cx& c, ValList& args);
   void exp(Cx& c, Val& v);
   void block(Cx& c);
   void stat(Cx& c);
   void block_func(Cx& c);
   void extern_stat(Cx& c);
   void var_decl_expr(Cx& c, Val& v);
   void var_decl(Cx& c);
   void do_stat(Cx& c);
   void bool_exp(Cx& c, Val& v);
   void while_stat(Cx& c);
   void assign_expr(Cx& c, Val& v);
   void stat2(Cx& c);
   void initializer_list(Cx& c, Val& v);
   void AssignOp(int& op);
   void exp1(Cx& c, Val& v);
   void exp2(Cx& c, Val& v);
   void exp3(Cx& c, Val& v);
   void exp_eq(Cx& c, Val& v);
   void EqOp(int& op);
   void exp_test(Cx& c, Val& v);
   void TestOp(int& op);
   void exp_add(Cx& c, Val& v);
   void AddOp(int& op);
   void exp_mult(Cx& c, Val& v);
   void MulOp(int& op);
   void exp5(Cx& c, Val& v);
   void exp6(Cx& c, Val& v);
   void exp7(Cx& c, Val& v);
   void atom(Cx& c, Val& v);
   void trailer(Cx& c, Val& v);
   void formal_param_list(Cx& c, Fn& f);

   // ***Production Header End

private:
   void SynErr(int n);
   void Get();
   void Expect(int n);
   bool StartOf(int s);
   void ExpectWeak(int n, int follow);
   bool WeakSeparator(int n, int syFol, int repFol);

   Token* mDummyTokenPtr{nullptr};
   int    mErrDist{2};
   int    mMinErrDist{2};

}; // end Parser

} // namespace Us

#endif
