// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// Copyright 2003-2015 The Boeing Company. All rights reserved.
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************

#include "WsfExecution.hpp"

#include <cassert>

#include <QTextBlock>
#include <QTextCursor>
#include <QUrl>
#include <QUrlQuery>

#include "LogServerPrefObject.hpp"
#include "Project.hpp"
#include "RunEnvManager.hpp"
#include "Util.hpp"
#include "WkfEnvironment.hpp"
#include "WsfExe.hpp"

wizard::WsfExecution::WsfExecution(QString aName, WsfExe* aExePtr, const UtPath& aWorkingDir, const QStringList& aArguments)
   : QProcess()
   , mName(aName)
{
   setProcessChannelMode(MergedChannels);

   mOutputText = QSharedPointer<QTextDocument>(new QTextDocument);
   mDone       = false;
   mExitStatus = NormalExit;

   mWorkingDir = aWorkingDir;
   setWorkingDirectory(mWorkingDir.GetSystemPath().c_str());
   mExePtr    = aExePtr;
   mArguments = aArguments;
   QFont font = mOutputText->defaultFont();
   font.setFamily("Monospace");
   font.setStyleHint(QFont::TypeWriter);
   mOutputText->setDefaultFont(font);
   mOutputText->setUndoRedoEnabled(false);
   // mOutputText->setDefaultStyleSheet("white-space: pre");

   connect(this, &WsfExecution::readyReadStandardOutput, this, &WsfExecution::ReadyReadStandardOutput);
   connect(this, static_cast<void (WsfExecution::*)(int)>(&WsfExecution::finished), this, &WsfExecution::Finished);

   // These are the two formats WSF has for error location.
   // WSF may omit the ending single quote.
   mInFileLineColExp.setPattern("('([^']*)'?,.line (\\d+),.near column.(\\d+))");
   mInFileEofExp.setPattern("('([^']*)'?.at.end-of-file)");
   mErrExp.setPattern(R"(^(\*\*\*\*\* \w+:) )");

   assert(mInFileLineColExp.isValid());
   assert(mInFileEofExp.isValid());
   assert(mErrExp.isValid());
}

void wizard::WsfExecution::Start(const std::vector<UtPath>& aStartupFiles)
{
   QStringList args = mArguments;

   bool        usingSettingsFile = false;
   std::string settingsFileContents =
      "# File generated by AFSIM Wizard\n# DO NOT MODIFY, YOUR CHANGES WILL BE OVERWRITTEN\n";

   if (mConnectionParameters.mUsingXIO)
   {
      usingSettingsFile = true;
      settingsFileContents += DebugSettingsString(mConnectionParameters.mXIO_Port);
   }

   if (usingSettingsFile)
   {
      if (!aStartupFiles.empty())
      {
         UtPath      ideConfFile = aStartupFiles[0];
         std::string newFileName = ideConfFile.GetFileName() + ".ide_conf"; // NAC+ TODO: Revisit this?
         ideConfFile.Up();
         ideConfFile += newFileName;
         std::string   ideConfFilePathRelativePath = mWorkingDir.GetRelativePath(ideConfFile).GetSystemPath();
         std::ofstream tmpStream(ideConfFile.GetSystemPath().c_str());
         tmpStream << settingsFileContents;
         tmpStream.close();

         args.push_back(ideConfFilePathRelativePath.c_str());
      }
   }

   if (!mOutputLog.fileName().isEmpty())
   {
      mOutputLog.open(QFile::WriteOnly);
   }

   QString exePath = QString::fromStdString(mExePtr->GetPath().GetSystemPath());
   QString output  = QString("> " + exePath + " " + args.join(" ") + "\n");
   emit    StandardOutputText(output);
   start(exePath, args, QProcess::ReadOnly);
   mStarted = true;
}

void wizard::WsfExecution::ReadyReadStandardOutput()
{
   QString newText = readAllStandardOutput();
   if (!newText.isEmpty())
   {
      emit StandardOutputText(newText);
      if (mOutputLog.isOpen())
      {
         mOutputLog.write(newText.toUtf8());
      }
   }
}

void wizard::WsfExecution::Finished()
{
   if (!mDone)
   {
      mDone = true;
      ReadyReadStandardOutput();
      if (mOutputLog.isOpen())
      {
         mOutputLog.close();
      }
      emit Done();
      // Added disconnect statement here to prevent crash that occurs when std::out gets backlogged and the user hits
      // the kill button Kill() is an asyncronise call to the OS, if std::out is back logged this signal may be
      // triggered even after the deleteLater event is a process and this object is deleted.  When this occurs, it is a
      // crash
      disconnect(this, &WsfExecution::readyReadStandardOutput, nullptr, nullptr);
      deleteLater();
   }
}

void wizard::WsfExecution::LimitOutputSize(QTextCursor* aCursorPtr)
{
   const int maxDocLines = 10000;
   int       linesTooBig = aCursorPtr->document()->lineCount() - maxDocLines;
   if (linesTooBig > 200) // seems to be expensive, only remove chunks at a time
   {
      aCursorPtr->movePosition(QTextCursor::Start);
      aCursorPtr->movePosition(QTextCursor::Down, QTextCursor::KeepAnchor, linesTooBig);
      aCursorPtr->removeSelectedText();
   }
}

void wizard::WsfExecution::Kill()
{
   mExitStatus = CrashExit;
   kill();
   if (!mDone)
   {
      mDone = true;
      ReadyReadStandardOutput();
      emit Done();
      // Added disconnect statement here to prevent crash that occurs when std::out gets backlogged and the user hits
      // the Kill button.
      //  Kill() is a asyncronise call to the OS, if std::out is back logged this signal may be triggered even after the
      //  deleteLater event is process and this object is deleted. When this occurs, it is a crash.
      disconnect(this, &WsfExecution::readyReadStandardOutput, nullptr, nullptr);
      deleteLater();
   }
}

std::string wizard::WsfExecution::DebugSettingsString(int aPort)
{
   std::stringstream tmpStream;
   // clang-format off
   tmpStream
      << "############## Debugger Settings ##############\n"
      << "# The following inputs configure WSF to connect \n"
      << "# to this instance of the AFSIM Wizard.\n"
      << "# This text should be added to your WSF inputs\n"
      << "###############################################\n"
      << "xio_interface \n"
      << "   unicast 127.0.0.1                  # Change to this hostname if running from another machine\n"
      << "   send_port " << aPort << std::endl
      << "   pause_for_connection yes\n"
      << "   debug on\n"
      << "   verbose on\n"
      << "end_xio_interface\n"
      << "realtime\n";
   // clang-format on

   // Set minimum mover timestep to 0 if unset, to ensure debug and non-debug output are the same.
   WsfPM_Root     proxyRoot(wizard::Project::Instance()->Proxy());
   WsfProxy::Time minimumMoverTimeStepValue = proxyRoot.simulation().GetMinimumMoverTimeStep();
   if (minimumMoverTimeStepValue.IsUnset())
   {
      tmpStream << "minimum_mover_timestep 0 s\n";
   }

   UtPath debugScriptsPath = RunEnvManager::GetDataDir() + "_wsf_debug_scripts_.txt";
   if (debugScriptsPath.Stat() == UtPath::cFILE)
   {
      tmpStream << "\n# This file contains scripts which enhance the watch variable values\n";
      tmpStream << "include_once \"" << debugScriptsPath.GetSystemPath() << "\"\n";
   }
   return tmpStream.str();
}

void wizard::WsfExecution::SetOutputLogPath(const QString& aPath)
{
   if (!aPath.isEmpty())
   {
      mOutputLog.setFileName(aPath);
   }
}

wizard::WsfExecution* wizard::WsfExecution::NewExecution(WsfExe*                    aExe,
                                                         const UtPath&              aWorkingDir,
                                                         const std::vector<UtPath>& aStartupFiles,
                                                         const QString&             aCmdLineArgs,
                                                         const QString&             aProjectName,
                                                         int                        aXioRecvPort,
                                                         bool                       aUseDebugging)
{
   if (aExe && !aExe->GetPath().GetNormalizedPath().empty())
   {
      // aProject.WorkingDirectory();
      // mWorkingDirectory.SetWorkingDirectory();

      // Note: Command line is automatically split on spaces.
      //  Quoted strings should be kept together, but THIS IS NOT DONE NOW
      QMap<QString, QString> cmdLineVars;
      QString                projFiles;
      for (const auto& startup : aStartupFiles)
      {
         if (!projFiles.isEmpty())
         {
            projFiles += ' ';
         }
         QString pathStr = Util::QuotePathWithSpaces(aWorkingDir.GetRelativePath(startup).GetSystemPath().c_str());
         projFiles       = projFiles + pathStr;
      }
      cmdLineVars["SCENARIO_FILES"] = projFiles;


      QStringList            argList     = Util::SplitCommandLine(aCmdLineArgs, cmdLineVars);
      LogServer::PrefObject* preferences = wkfEnv.GetPreferenceObject<LogServer::PrefObject>();
      if (preferences) // this means log server plugin is loaded, we can extract port.
      {
         QString port = QString::number(preferences->GetLogServerPort());
         argList.push_front(port);
         argList.push_front("-log-server-port");
         argList.push_front("localhost");
         argList.push_front("-log-server-host");
      }

      WsfExecution* execPtr = new WsfExecution(aProjectName, aExe, aWorkingDir, argList);
      if (aUseDebugging)
      {
         execPtr->mConnectionParameters.mUsingXIO      = true;
         execPtr->mConnectionParameters.mXIO_Address   = "127.0.0.1";
         execPtr->mConnectionParameters.mXIO_Interface = "127.0.0.1";
         execPtr->mConnectionParameters.mXIO_Port      = aXioRecvPort;
      }

      return execPtr;
   }
   return nullptr;
}
