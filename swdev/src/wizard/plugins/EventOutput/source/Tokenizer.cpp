// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// Copyright 2020 Infoscitex, a DCS Company. All rights reserved.
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************

#include "Tokenizer.hpp"

#include <QTextDocument>
#include <QTextDocumentFragment>

#include "PluginUtil.hpp"
#include "SettingValueWidget.hpp"
#include "SettingWidget.hpp"
#include "TextSource.hpp"

namespace wizard
{
namespace EventOutput
{
namespace editor
{
namespace tokenizer
{

static const QString cDEFAULT_INDENT{"   "};


const StateMachine::TokenList& StateMachine::Tokenize(const QString& aText)
{
   // prepare to tokenize
   State state{State::cDEFAULT};
   int   row{0};
   int   column{0};
   int   position{0};

   // process each character of the string
   for (QChar c : aText)
   {
      switch (state)
      {
      case State::cDEFAULT:
         state = DefaultState(c, row, column, position);
         break;
      case State::cIDENTIFIER:
         state = IdentifierState(c, row, column, position);
         break;
      case State::cSTRING:
         state = StringState(c, row, column, position);
         break;
      case State::cSTRING_ESC:
         state = StringEscState(c, row, column, position);
         break;
      case State::cSLASH:
         state = SlashState(c, row, column, position);
         break;
      case State::cLINE_COMMENT:
         state = LineCommentState(c, row, column, position);
         break;
      case State::cBLOCK_COMMENT:
         state = BlockCommentState(c, row, column, position);
         break;
      case State::cBLOCK_COMMENT_ESC:
         state = BlockCommentEscState(c, row, column, position);
         break;
      default:
         break;
      }

      if (c == '\n')
      {
         ++row;
         column = 0;
         ++position;
      }
      else
      {
         ++column;
         ++position;
      }
   }

   return mTokens;
}

//! Determines whether or not the command is valid
//! @param aType is the type of AFSIM input block (as a string)
//! @param aCommand is the name of the property
//! @return whether or not the command is valid
bool IsValidCommand(const QString& aType, const QString& aCommand)
{
   // acquire the setting::Widget from the EventOutput::Dialog
   setting::Widget* sw{nullptr};
   emit             evtOutSignals->AcquireSettings(sw, aType);
   // determine whether or not the command is valid
   for (auto elem : sw->GetAvailableCommands())
   {
      if (elem == aCommand)
      {
         return true;
      }
   }
   // disable and enable are valid commands
   if (aCommand == "disable" || aCommand == "enable")
   {
      return true;
   }
   return false;
};

void StateMachine::Classify(TokenList& aTokenList, const BlockTags& aTags)
{
   bool inEventOutputBlock{false};
   bool foundCommand{false};
   // iterate through all of the tokens (generated by Tokenize) and classify them
   for (auto iter = aTokenList.begin(); iter != aTokenList.end(); ++iter)
   {
      auto& curElem = *iter;
      // a line comment
      if (curElem.mText.startsWith("//") || curElem.mText.startsWith('#'))
      {
         curElem.mMetadata.mType = TokenType::cLINE_COMMENT;
      }
      // a block comment
      else if (curElem.mText.startsWith("/*") && curElem.mText.endsWith("*/"))
      {
         curElem.mMetadata.mType = TokenType::cBLOCK_COMMENT;
      }
      // the start of the intended block
      else if (!inEventOutputBlock && curElem.mText == aTags.mBeginTag)
      {
         inEventOutputBlock      = true;
         curElem.mMetadata.mType = TokenType::cBEGIN_EVENT_OUTPUT;
      }
      // the end of the intended block
      else if (inEventOutputBlock && curElem.mText == aTags.mEndTag)
      {
         inEventOutputBlock      = false;
         curElem.mMetadata.mType = TokenType::cEND_EVENT_OUTPUT;
      }
      // this is the juicy section
      // it classifies the command-value pairs inside the intended block
      else if (inEventOutputBlock)
      {
         if (!foundCommand && curElem.mMetadata.mType == TokenType::cUNCLASSIFIED &&
             IsValidCommand(aTags.mBeginTag, curElem.mText))
         {
            curElem.mMetadata.mType = TokenType::cCOMMAND;
            foundCommand            = true;
         }
         else if (foundCommand && curElem.mMetadata.mType == TokenType::cUNCLASSIFIED)
         {
            curElem.mMetadata.mType = TokenType::cVALUE;
            foundCommand            = false;
         }
      }
      // the unwanted block conditional is the catch-all
      // Note:  this is to catch a sequence of tokens like this:
      //        platform event_output
      //        end_platform
      //        platform end_event_output
      //        end_platform
      //        although, it does catch everything else that is not the intended block...
      //        also, it ignores the intended block if nested within another block.
      //        however, that is invalid input anyway because (csv_)event_output cannot be a nested block.
      else if (!inEventOutputBlock)
      {
         curElem.mMetadata.mType = TokenType::cBEGIN_BLOCK;
         bool foundEndBlock{false};
         for (auto blockIter = iter; blockIter != aTokenList.end(); ++blockIter)
         {
            // it is an actual unwanted block
            if (blockIter->mText == "end_" + curElem.mText)
            {
               blockIter->mMetadata.mType = TokenType::cEND_BLOCK;
               iter                       = blockIter;
               foundEndBlock              = true;
               break;
            }
         }
         // it was just a fluke...
         if (!foundEndBlock)
         {
            curElem.mMetadata.mType = TokenType::cUNCLASSIFIED;
         }
      }
   }
}

void StateMachine::BeginToken(const size_t aRow, const size_t aColumn, const size_t aPosition)
{
   mTokens += token::Token{"", TokenMetaData{TokenType::cUNCLASSIFIED, aPosition, aRow, aColumn}};
}

void StateMachine::PushChar(const QChar aCharacter)
{
   mTokens.back().mText += aCharacter;
}

bool StateMachine::IsPartOfIdentifier(const QChar aCharacter) const
{
   return aCharacter.isLetter() || aCharacter.isDigit() || aCharacter == '_' || aCharacter == '.' || aCharacter == ':';
}

StateMachine::State
StateMachine::DefaultState(const QChar aNextChar, const size_t aRow, const size_t aColumn, const size_t aPosition)
{
   if (IsPartOfIdentifier(aNextChar))
   {
      BeginToken(aRow, aColumn, aPosition);
      PushChar(aNextChar);
      return State::cIDENTIFIER;
   }
   else if (aNextChar == '/')
   {
      BeginToken(aRow, aColumn, aPosition);
      PushChar(aNextChar);
      return State::cSLASH;
   }
   else if (aNextChar == '\"')
   {
      BeginToken(aRow, aColumn, aPosition);
      PushChar(aNextChar);
      return State::cSTRING;
   }
   else if (aNextChar == '#')
   {
      BeginToken(aRow, aColumn, aPosition);
      PushChar(aNextChar);
      return State::cLINE_COMMENT;
   }
   else if (!aNextChar.isSpace())
   {
      BeginToken(aRow, aColumn, aPosition);
      PushChar(aNextChar);
      return State::cDEFAULT;
   }
   return State::cDEFAULT;
}

StateMachine::State
StateMachine::IdentifierState(const QChar aNextChar, const size_t aRow, const size_t aColumn, const size_t aPosition)
{
   if (IsPartOfIdentifier(aNextChar))
   {
      PushChar(aNextChar);
      return State::cIDENTIFIER;
   }

   return DefaultState(aNextChar, aRow, aColumn, aPosition);
}

StateMachine::State StateMachine::StringState(const QChar aNextChar, const size_t aRow, const size_t aColumn, const size_t aPosition)
{
   if (aNextChar == '\\')
   {
      return State::cSTRING_ESC;
   }

   PushChar(aNextChar);

   if (aNextChar == '\"')
   {
      return State::cDEFAULT;
   }
   return State::cSTRING;
}

StateMachine::State
StateMachine::StringEscState(const QChar aNextChar, const size_t aRow, const size_t aColumn, const size_t aPosition)
{
   PushChar(aNextChar);
   return State::cSTRING;
}

StateMachine::State StateMachine::SlashState(const QChar aNextChar, const size_t aRow, const size_t aColumn, const size_t aPosition)
{
   if (aNextChar == '/')
   {
      PushChar(aNextChar);
      return State::cLINE_COMMENT;
   }
   else if (aNextChar == '*')
   {
      PushChar(aNextChar);
      return State::cBLOCK_COMMENT;
   }

   return DefaultState(aNextChar, aRow, aColumn, aPosition);
}

StateMachine::State
StateMachine::LineCommentState(const QChar aNextChar, const size_t aRow, const size_t aColumn, const size_t aPosition)
{
   if (aNextChar == '\n')
   {
      return State::cDEFAULT;
   }

   PushChar(aNextChar);
   return State::cLINE_COMMENT;
}

StateMachine::State
StateMachine::BlockCommentState(const QChar aNextChar, const size_t aRow, const size_t aColumn, const size_t aPosition)
{
   PushChar(aNextChar);
   if (aNextChar == '*')
   {
      return State::cBLOCK_COMMENT_ESC;
   }
   return State::cBLOCK_COMMENT;
}

StateMachine::State StateMachine::BlockCommentEscState(const QChar  aNextChar,
                                                       const size_t aRow,
                                                       const size_t aColumn,
                                                       const size_t aPosition)
{
   PushChar(aNextChar);
   if (aNextChar == '/')
   {
      return State::cDEFAULT;
   }
   else if (aNextChar == '*')
   {
      return State::cBLOCK_COMMENT_ESC;
   }

   return State::cBLOCK_COMMENT;
}

Tokenizer::Tokenizer(BlockTags aTags)
   : mTags(std::move(aTags))
{
}

Tokenizer::Tokenizer(TextSource* aSourcePtr, BlockTags aTags)
   : mTags(std::move(aTags))
   , mSource(aSourcePtr)
{
   FindRangeInQtDocument();
}

void Tokenizer::SetSource(TextSource* aSourcePtr)
{
   mSource = aSourcePtr;
   FindRangeInQtDocument();
}

const wizard::TextSource* Tokenizer::GetSource() const
{
   return mSource;
}

QTextCursor Tokenizer::GetRangeFromQtDocument() const
{
   return mQtRange;
}

void Tokenizer::InsertSetting(const QString& aSetting, const QString& aValue)
{
   mSettings.insert(token::CommandString{aSetting}, token::SettingCVP{aSetting, aValue});
}

void Tokenizer::RemoveSetting(const QString& aSetting)
{
   mSettings.remove(token::CommandString{aSetting});
}

void Tokenizer::SetSetting(const QString& aSetting, const QString& aValue)
{
   auto iter = mSettings.find(token::CommandString{aSetting});
   if (iter != mSettings.end())
   {
      iter->SetValue(aValue);
   }
}

const token::CommandValuePair* Tokenizer::GetSetting(const QString& aSetting) const
{
   const auto& iter = mSettings.find(token::CommandString{aSetting});
   if (iter != mSettings.end())
   {
      return &iter.value();
   }
   else
   {
      return nullptr;
   }
}

void Tokenizer::SetSettings(const QMap<token::CommandString, token::SettingCVP>& aSettingList)
{
   mSettings = aSettingList;
}

const QMap<token::CommandString, token::SettingCVP>& Tokenizer::GetSettings() const
{
   return mSettings;
}

void Tokenizer::ValidateSettings(const QStringList& aValidSettings)
{
   for (auto iter = mSettings.begin(); iter != mSettings.end();)
   {
      if (!aValidSettings.contains(iter->GetCommand()))
      {
         iter = mSettings.erase(iter);
      }
      else
      {
         ++iter;
      }
   }
}

void Tokenizer::InsertEvent(const QString& aEvent, const QString& aValue)
{
   mEvents.insert(token::CommandString{aEvent}, token::EventCVP{aEvent, aValue});
}

void Tokenizer::RemoveEvent(const QString& aEvent)
{
   mEvents.remove(token::CommandString{aEvent});
}

void Tokenizer::SetEvent(const QString& aEvent, const QString& aValue)
{
   auto iter = mEvents.find(token::CommandString{aEvent});
   if (iter != mEvents.end())
   {
      iter->SetValue(aValue);
   }
}

const token::CommandValuePair* Tokenizer::GetEvent(const QString& aEvent) const
{
   const auto& iter = mEvents.find(token::CommandString{aEvent});
   if (iter != mEvents.end())
   {
      return &iter.value();
   }
   else
   {
      return nullptr;
   }
}

void Tokenizer::SetEvents(const QMap<token::CommandString, token::EventCVP>& aEventList)
{
   mEvents = aEventList;
}

const QMap<token::CommandString, token::EventCVP>& Tokenizer::GetEvents() const
{
   return mEvents;
}

void Tokenizer::ValidateEvents(const QStringList& aValidEvents)
{
   for (auto iter = mEvents.begin(); iter != mEvents.end();)
   {
      if (!aValidEvents.contains(iter->GetCommand()))
      {
         iter = mEvents.erase(iter);
      }
      else
      {
         ++iter;
      }
   }
}

void Tokenizer::SetNeedToSave(bool aNeedToSave)
{
   mNeedToSave = aNeedToSave;
}

bool Tokenizer::NeedToSave() const
{
   return mNeedToSave;
}

bool Tokenizer::ConnectToEditor(const Editor* aEditor)
{
   // do not allow the connection if the Tokenizer is already connected
   if (mEditorPtr)
   {
      return false;
   }
   else
   {
      mEditorPtr = aEditor;
      return true;
   }
}

void Tokenizer::CreateCVPsFromTokens()
{
   mSettings.clear();
   mEvents.clear();
   QString eventOutputBlock;
   if (!IsCached())
   {
      eventOutputBlock = mQtRange.selection().toPlainText();
   }
   else
   {
      eventOutputBlock = mBlockCache.value();
   }

   if (!eventOutputBlock.isEmpty())
   {
      auto beginIter = BeginEventOutput();
      auto endIter   = EndEventOutput();
      for (auto iter = beginIter; iter != endIter; ++iter)
      {
         auto& curElem  = *iter;
         auto& nextElem = *(iter + 1);

         if (curElem.mMetadata.mType == TokenType::cCOMMAND && nextElem.mMetadata.mType == TokenType::cVALUE)
         {
            bool disableOrEnable{curElem.mText.contains("disable") || curElem.mText.contains("enable")};
            if (disableOrEnable)
            {
               mEvents.insert(token::CommandString{nextElem.mText}, token::EventCVP{nextElem.mText, curElem.mText});
            }
            else
            {
               setting::ValueWidget::Type itype;
               emit                       evtOutSignals->AcquireCommandInputType(itype, curElem.mText);
               if (itype == setting::ValueWidget::Type::cMULTIPLE_CHOICE)
               {
                  auto GetLiteralToken = [](TokenList::iterator aBegin, TokenList::iterator aEnd)
                  {
                     const size_t row{aBegin->mMetadata.mRow};
                     const size_t column{aBegin->mMetadata.mColumn};
                     QString      path;
                     while (aBegin != aEnd)
                     {
                        if (aBegin->mMetadata.mRow == row && aBegin->mMetadata.mColumn == column + path.size())
                        {
                           path += aBegin->mText;
                        }
                        ++aBegin;
                     }
                     return path;
                  };
                  mSettings.insert(token::CommandString{curElem.mText},
                                   token::SettingCVP{curElem.mText, GetLiteralToken(&nextElem, mTokens.end())});
               }
               else
               {
                  mSettings.insert(token::CommandString{curElem.mText}, token::SettingCVP{curElem.mText, nextElem.mText});
               }
            }
         }
      }
   }

   mBlockCache.reset();
}

void Tokenizer::CreateStringFromCVPs()
{
   QStringList lines;
   if (mQtRange.selection().isEmpty())
   {
      lines.append("");
   }
   lines.append(mTags.mBeginTag);
   for (const auto& t : mSettings)
   {
      lines.append(cDEFAULT_INDENT + t.ToString());
   }
   if (!mSettings.isEmpty() && !mEvents.isEmpty())
   {
      lines.append("");
   }
   for (const auto& t : mEvents)
   {
      lines.append(cDEFAULT_INDENT + t.ToString());
   }
   lines.append(mTags.mEndTag);
   mBlockCache = ut::make_optional<QString>(lines.join('\n'));
}

QString Tokenizer::GetCache() const
{
   if (mBlockCache.has_value())
   {
      return mBlockCache.value();
   }
   else
   {
      return "";
   }
}

bool Tokenizer::IsCached() const
{
   return mBlockCache.has_value();
}

void Tokenizer::FindRangeInQtDocument()
{
   QTextDocument* qtSource{mSource->GetDocumentAsQTextDocument()};
   QString        qtSourceText{qtSource->toPlainText()};
   StateMachine   sm;
   mTokens = sm.Tokenize(qtSourceText);
   sm.Classify(mTokens, mTags);
   QTextCursor qtBlockRange{qtSource};
   auto        beginIter = BeginEventOutput();
   if (beginIter != mTokens.end())
   {
      qtBlockRange.setPosition(ut::cast_to_int(BeginEventOutput()->mMetadata.mPosition), QTextCursor::MoveAnchor);
   }
   else
   {
      qtBlockRange.setPosition(ut::cast_to_int(mSource->Size() - 1), QTextCursor::MoveAnchor);
   }
   auto endIter = EndEventOutput();
   if (endIter != mTokens.end())
   {
      qtBlockRange.setPosition(ut::cast_to_int(EndEventOutput()->mMetadata.mPosition + EndEventOutput()->mText.size()),
                               QTextCursor::KeepAnchor);
   }
   mQtRange = qtBlockRange;
}

Tokenizer::TokenList::iterator Tokenizer::BeginEventOutput()
{
   for (auto iter = mTokens.begin(); iter != mTokens.end(); ++iter)
   {
      if (iter->mMetadata.mType == TokenType::cBEGIN_EVENT_OUTPUT)
      {
         return iter;
      }
   }
   return mTokens.end();
}

Tokenizer::TokenList::iterator Tokenizer::EndEventOutput()
{
   for (auto iter = mTokens.begin(); iter != mTokens.end(); ++iter)
   {
      if (iter->mMetadata.mType == TokenType::cEND_EVENT_OUTPUT)
      {
         return iter;
      }
   }
   return mTokens.end();
}

} // namespace tokenizer
} // namespace editor
} // namespace EventOutput
} // namespace wizard
