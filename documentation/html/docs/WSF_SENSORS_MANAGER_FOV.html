
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>WSF_SENSORS_MANAGER_FOV &#8212; AFSIM 2.9.0 Documentation</title>
    <link rel="stylesheet" href="../_static/wsftheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/collapse.css" />
    <link rel="stylesheet" type="text/css" href="../_static/admonition.css" />
    <link rel="stylesheet" type="text/css" href="../_static/table.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pseudo-header.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pseudo-topic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/quick-search.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/collapse_sections.js"></script>
    
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="WSF_SIMPLE_COVERAGE_MOE" href="wsf_simple_coverage.html" />
    <link rel="prev" title="WSF_SENSORS_MANAGER" href="WSF_SENSORS_MANAGER.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a></li>
        <li class="right" >
          <a href="../wsf-classindex.html" title="Script Class Index"
             >classes</a> |</li>
        <li class="right" >
          <a href="../wsf-commandindex.html" title="Command Index"
             >commands</a> |</li>
        <li class="right" >
          <a href="../wsf-modelindex.html" title="Model Index"
             >models</a> |</li>
        <li class="right" >
          <a href="../wsf-demoindex.html" title="Demo Index"
             >demos</a> |</li>
        <li class="right" >
          <a href="wsf_simple_coverage.html" title="WSF_SIMPLE_COVERAGE_MOE"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="WSF_SENSORS_MANAGER.html" title="WSF_SENSORS_MANAGER"
             accesskey="P">previous</a> |</li>
  <li>
    <img src="../_static/relbar_logo.png" alt=""
         style="vertical-align: middle; margin-top: -2px" />
  </li>
  <li>
    <a href="main_page.html">AFSIM 2.9.0 Documentation</a> &#187;
  </li>
  
        <li class="nav-item nav-item-0"><a href="../site_index.html">Site Index</a> &#187;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="wsf-sensors-manager-fov">
<h1>WSF_SENSORS_MANAGER_FOV<a class="headerlink" href="#wsf-sensors-manager-fov" title="Permalink to this headline">¶</a></h1>
<dl class="model">
<dt id="WSF_SENSORS_MANAGER_FOV">
processor WSF_SENSORS_MANAGER_FOV<a class="headerlink" href="#WSF_SENSORS_MANAGER_FOV" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Derives From:</strong> <a class="reference internal" href="WSF_SIMPLE_SENSORS_MANAGER.html#WSF_SIMPLE_SENSORS_MANAGER" title="WSF_SIMPLE_SENSORS_MANAGER"><span class="xref wsf wsf-model">WSF_SIMPLE_SENSORS_MANAGER</span></a></p>
<p>Script Class: <a class="reference internal" href="WsfSensorsManagerFOV.html#WsfSensorsManagerFOV" title="WsfSensorsManagerFOV"><span class="xref wsf wsf-class">WsfSensorsManagerFOV</span></a></p>
<pre class="literal-block">processor &lt;name&gt; <a class="reference internal" href="#WSF_SENSORS_MANAGER_FOV" title="WSF_SENSORS_MANAGER_FOV"><span class="xref wsf wsf-model">WSF_SENSORS_MANAGER_FOV</span></a>
   <a class="reference internal" href="WSF_SIMPLE_SENSORS_MANAGER.html#WSF_SIMPLE_SENSORS_MANAGER" title="WSF_SIMPLE_SENSORS_MANAGER"><span class="xref wsf wsf-model">WSF_SIMPLE_SENSORS_MANAGER</span></a> Commands ...


end_processor</pre>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#WSF_SENSORS_MANAGER_FOV" title="WSF_SENSORS_MANAGER_FOV"><span class="xref wsf wsf-model">WSF_SENSORS_MANAGER_FOV</span></a> extends <a class="reference internal" href="WSF_SIMPLE_SENSORS_MANAGER.html#WSF_SIMPLE_SENSORS_MANAGER" title="WSF_SIMPLE_SENSORS_MANAGER"><span class="xref wsf wsf-model">WSF_SIMPLE_SENSORS_MANAGER</span></a> to provide more sophisticated slewing control. It is identical in all other respects. While the simple sensor manager points a TTR directly at assigned targets in an undefined order, the sensor manager FOV slews a TTR to the region of space in which it could see the most targets. The full sensor manager FOV algorithm is given in the <a class="reference internal" href="#updating">Updating</a> section below. For brevity, this page will often refer to a <strong>WSF_SENSORS_MANAGER_FOV</strong> as simply “the sensor manager” or “the manager.”</p>
</section>
<section id="ttr-aux-data">
<h2>TTR aux_data<a class="headerlink" href="#ttr-aux-data" title="Permalink to this headline">¶</a></h2>
<p>The sensor manager queries <a class="reference internal" href="aux_data.html#_.aux_data" title="aux_data (_)"><span class="xref wsf wsf-command">aux_data</span></a> defined in subordinate TTRs to discover additional sensor parameters. Note that these parameters are not defined in a sensor manager’s <a class="reference internal" href="aux_data.html#_.aux_data" title="aux_data (_)"><span class="xref wsf wsf-command">aux_data</span></a>, but in that of a TTR <a class="reference internal" href="sensor.html#sensor" title="sensor"><span class="xref wsf wsf-command">sensor</span></a>. If an auxiliary parameter is not specified, it will be set to a default value.</p>
<span class="target" id="sm-fov-resting-azimuth"></span><dl class="command">
<dt id="WSF_SENSORS_MANAGER_FOV.unitary">
<span id="unitary"></span>unitary RESTING_AZIMUTH =<a class="reference internal" href="argumenttypes.html#angle-value" title="angle-value"><em> &lt;angle-value&gt;</em></a><a class="headerlink" href="#WSF_SENSORS_MANAGER_FOV.unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>The azimuth to which the TTR will return when it has no more assignments. This azimuth is defined in the <a class="reference internal" href="coordinate_systems.html#pcs"><span class="std std-ref">PCS frame</span></a> of the the TTR (thus, setting this value to 0 degrees points the resting azimuth directly in front of the sensor, 90 degrees points it to the right, -90 to the left, and 180 degrees directly behind). Since this is an azmiuth, it should be in the range [-180, 180] degrees.</p>
<p><strong>Default:</strong> 0 degrees</p>
</dd></dl>

<span class="target" id="sm-fov-coarse-slew-rate"></span><dl class="command">
<dt id="WSF_SENSORS_MANAGER_FOV.unitary">
<span id="unitary"></span>unitary COARSE_SLEW_RATE_AZIMUTH =<a class="reference internal" href="argumenttypes.html#angular-speed-value" title="angular-speed-value"><em> &lt;angular-speed-value&gt;</em></a><a class="headerlink" href="#WSF_SENSORS_MANAGER_FOV.unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>The speed at which the TTR will slew in azimuth when it does not have targets in its field of view.</p>
<p><strong>Default:</strong> Infinity</p>
</dd></dl>

<span class="target" id="sm-fov-fine-slew-rate"></span><dl class="command">
<dt id="WSF_SENSORS_MANAGER_FOV.unitary">
<span id="unitary"></span>unitary FINE_SLEW_RATE_AZIMUTH =<a class="reference internal" href="argumenttypes.html#angular-speed-value" title="angular-speed-value"><em> &lt;angular-speed-value&gt;</em></a><a class="headerlink" href="#WSF_SENSORS_MANAGER_FOV.unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>The speed at which the TTR will slew in azimuth when it has targets in its field of view.</p>
<p><strong>Default:</strong> Infinity</p>
</dd></dl>

</section>
<section id="ttr-restrictions">
<h2>TTR Restrictions<a class="headerlink" href="#ttr-restrictions" title="Permalink to this headline">¶</a></h2>
<p>The sensor manager takes control of some aspects of its subordinate TTRs. This includes the <a class="reference internal" href="platform_part_commands.html#_.platform_part.on" title="on (_.platform_part)"><span class="xref wsf wsf-command">on</span></a>/<a class="reference internal" href="platform_part_commands.html#_.platform_part.off" title="off (_.platform_part)"><span class="xref wsf wsf-command">off</span></a> state; the <a class="reference internal" href="articulated_part.html#_.articulated_part.azimuth_slew_rate" title="azimuth_slew_rate (_.articulated_part)"><span class="xref wsf wsf-command">azimuth_slew_rate</span></a> and <a class="reference internal" href="sensor.html#sensor_mode.azimuth_cue_rate" title="azimuth_cue_rate (sensor_mode)"><span class="xref wsf wsf-command">azimuth_cue_rate</span></a>; and the cued location/angle/target. These aspects <strong>should not</strong> be modified from script. Doing so will interfere with the operation of the manager, and produce odd results. The manager also requires that TTR sensors use a default <a class="reference internal" href="sensor.html#sensor-detection-scheduling-commands"><span class="std std-ref">sensor scheduler</span></a>. Using another scheduler will also produce odd results.</p>
<p>The sensor manager only cues a TTR sensor to a single location, so it will not operate correctly for sensors with multiple antennas or beams if the antennas/beams can point in multiple directions at the same time. However, it is able manage multiple sensors if they are present on the same platform.</p>
</section>
<section id="computing-cue-azimuth">
<span id="sm-fov-computing-cue-azimuth"></span><h2>Computing Cue Azimuth<a class="headerlink" href="#computing-cue-azimuth" title="Permalink to this headline">¶</a></h2>
<p>The major responsibility of the sensor manager is to compute the direction in which to point a TTR by considering its current assignments. This section will refer to an assignment given to a TTR as a <em>target</em>. In computing the cue azimuth, the manager considers the azimuth of the target relative to the sensor, and whether or not the sensor is currently tracking the target. The image below is a top-down view of a set of targets around a TTR.</p>
<img alt="../_images/iads_c2_sm_fov_targets_top_down.png" src="../_images/iads_c2_sm_fov_targets_top_down.png" />
<p>The wedge containing the tracked targets T <code class="docutils literal notranslate"><span class="pre">8</span></code> and T <code class="docutils literal notranslate"><span class="pre">9</span></code> represents one possible azimuth of the sensor, where the angle of the wedge represents the width of the sensor beam. For radar sensors, this is typically the half-power beam width; for geometric sensors, it is the azimuth field of view; other sensor types may define this width differently. The cue azimuth is determined by finding the wedge that contains the most tracked targets. Given that two wedges contain the same number of tracked targets, the one with more targets (tracked or not) is chosen. Given that two wedges contain the same number of targets, the one with the denser target grouping (in azimuth) is chosen. Within this wedge, the manager cues the TTR to the middle of the target grouping (more precisely, the mean of all the target azimuths).</p>
<p>In the image above, T <code class="docutils literal notranslate"><span class="pre">3</span></code>, T <code class="docutils literal notranslate"><span class="pre">4</span></code>, and T <code class="docutils literal notranslate"><span class="pre">5</span></code> form a dense group that fit into an azimuth wedge; however, the sensor is already busy tracking two targets, T <code class="docutils literal notranslate"><span class="pre">8</span></code> and T <code class="docutils literal notranslate"><span class="pre">9</span></code>, so the TTR is cued such that its beam contains these two targets instead.</p>
<p>This strategy prevents the TTR from abandoning targets it is already tracking, prioritizes groups with more targets, and favors dense groups over sparse ones.</p>
</section>
<section id="updating">
<h2>Updating<a class="headerlink" href="#updating" title="Permalink to this headline">¶</a></h2>
<p>The sensor manager is updated periodically by the IADS C2 system. Each update, in addition to the base sensor manager duties, the FOV sensor manager performs some additional actions to each subordinate TTR. First, it checks if the TTR has any assignments. If not, the manager makes sure the TTR is turned off, sets its slew rate to the <a class="reference internal" href="#sm-fov-coarse-slew-rate"><span class="std std-ref">coarse slew rate</span></a>, and cues it to its <a class="reference internal" href="#sm-fov-resting-azimuth"><span class="std std-ref">resting azimuth</span></a>. Otherwise, the manager <a class="reference internal" href="#sm-fov-computing-cue-azimuth"><span class="std std-ref">computes the cue azimuth</span></a> for the TTR, and cues the TTR to this azimuth. If the cued azimuth is within the sensor’s current field of view, the manager makes sure the TTR is on, and sets its slew rate to the <a class="reference internal" href="#sm-fov-fine-slew-rate"><span class="std std-ref">fine slew rate</span></a>; otherwise, the manager makes sure the TTR is off, and sets its slew rate to the <a class="reference internal" href="#sm-fov-coarse-slew-rate"><span class="std std-ref">coarse slew rate</span></a>.</p>
</section>
<section id="computing-cue-azimuth-for-developers">
<h2>Computing Cue Azimuth - for Developers<a class="headerlink" href="#computing-cue-azimuth-for-developers" title="Permalink to this headline">¶</a></h2>
<p>The algorithm for computing the cue azimuth in the AFSIM port diverges from the original HELIOS implementation. The new version is more efficient and produces a more accurate result, though it may be difficult to understand from the code alone. The intent of this section is to explain the confusing parts of the algorithm. A <em>target</em> in this section refers to an assignment given to a TTR.</p>
<p>The image below will be freqeuntly referenced for the remainder of this section.</p>
<img alt="../_images/iads_c2_sm_fov_azimuth_window.png" src="../_images/iads_c2_sm_fov_azimuth_window.png" />
<p>This image shows a number line from -180 to 180 degrees, representing the azimuth angle around a sensor. Along the number line are a series of targets, represented by circles. The circles with a dot in the center are <em>tracked</em> targets. The gray box with an arrow to the right to it represents the azimuth field-of-view (called the <em>azimuth wedge</em> in the previous section); this will be called the <em>azimuth window</em> in the remainder of this section, or simply the window. It is easy to compute which targets are in a particular window by simply iterating over all targets, and checking if each target is within the minimum and maximum limits of the window. However, there are an infinite number of possible windows, so checking all of them is impossible. HELIOS solves this problem by trying 360 different windows, at 1 degree intervals. However, this is an expensive computation (unless the number of targets is very large, which is not typical). Also, considering that TTRs typically have a field of view of only a few degrees, the 1 degree increments could introduce some significant errors.</p>
<p>Referring to the image again, the graph above the number line shows the number of targets and the number of tracked targets when the right edge of the azimuth window is at a particular azimuth. Recall that azimuths wrap around at 180 degrees, so azimuth windows near -180 degrees also include targets near +180 degrees. The graph is a discrete function (that is, it is not a smooth curve, but a series of rising and falling edges). The graph changes values only when a target enters or exits the window as the window slides forward. We can compute the number of targets efficiently by the following algorithm:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">sort</span> <span class="n">targets</span> <span class="ow">in</span> <span class="n">ascending</span> <span class="n">order</span> <span class="n">by</span> <span class="n">azimuth</span>
<span class="n">sort</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span>

<span class="n">windowSize</span> <span class="o">=</span> <span class="n">field</span> <span class="n">of</span> <span class="n">view</span> <span class="n">of</span> <span class="n">window</span>
<span class="n">minIndex</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">maxIndex</span> <span class="o">=</span> <span class="mi">0</span>

<span class="o">//</span> <span class="n">find</span> <span class="n">which</span> <span class="n">targets</span> <span class="n">are</span> <span class="ow">in</span> <span class="n">initial</span> <span class="n">window</span>
<span class="n">WHILE</span> <span class="n">maxIndex</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span> <span class="n">AND</span> <span class="n">targets</span><span class="p">[</span><span class="n">maxIndex</span><span class="p">]</span><span class="o">.</span><span class="n">azimuth</span> <span class="o">&lt;=</span> <span class="n">windowSize</span>
   <span class="n">maxIndex</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">leftEdge</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">rightEdge</span> <span class="o">=</span> <span class="n">windowSize</span>
<span class="n">LOOP</span>
   <span class="o">//</span> <span class="n">handle</span> <span class="n">wraparound</span>
   <span class="n">wrappedMaxIndex</span> <span class="o">=</span> <span class="n">maxIndex</span> <span class="n">mod</span> <span class="n">length</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span>
   <span class="n">wrappedRightEdge</span> <span class="o">=</span> <span class="n">rightEdge</span>
   <span class="n">IF</span> <span class="n">wrappedRightEdge</span> <span class="o">&gt;</span> <span class="mi">180</span>
      <span class="n">wrappedRightEdge</span> <span class="o">-=</span> <span class="mi">360</span>

   <span class="n">minTargetDistance</span> <span class="o">=</span> <span class="n">targets</span><span class="p">[</span><span class="n">minIndex</span><span class="p">]</span><span class="o">.</span><span class="n">azimuth</span> <span class="o">-</span> <span class="n">leftEdge</span>
   <span class="n">maxTargetDistance</span> <span class="o">=</span> <span class="n">targets</span><span class="p">[</span><span class="n">wrappedMaxIndex</span><span class="p">]</span><span class="o">.</span><span class="n">azimuth</span> <span class="o">-</span> <span class="n">wrappedRightEdge</span>

   <span class="n">IF</span> <span class="n">maxTargetDistance</span> <span class="o">&gt;=</span> <span class="n">minTargetDistance</span>
      <span class="o">//</span> <span class="n">target</span> <span class="n">entering</span> <span class="n">window</span>
      <span class="n">maxIndex</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">slideDistance</span> <span class="o">=</span> <span class="n">maxTargetDistance</span>
   <span class="n">ELSE</span>
      <span class="o">//</span> <span class="n">target</span> <span class="n">exiting</span> <span class="n">window</span>
      <span class="n">minIndex</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">slideDistance</span> <span class="o">=</span> <span class="n">minTargetDistance</span>

   <span class="o">//</span> <span class="n">advance</span> <span class="n">the</span> <span class="n">window</span>
   <span class="n">leftEdge</span> <span class="o">+=</span> <span class="n">slideDistance</span>
   <span class="n">rightEdge</span> <span class="o">=</span> <span class="n">leftEdge</span> <span class="o">+</span> <span class="n">windowsSize</span>

   <span class="n">IF</span> <span class="n">leftEdge</span> <span class="o">&gt;=</span> <span class="mi">180</span>
      <span class="n">BREAK</span>

   <span class="n">targetCount</span> <span class="o">=</span> <span class="n">maxIndex</span> <span class="o">-</span> <span class="n">minIndex</span>
</pre></div>
</div>
<p>The algorithm keeps track of the targets in the window using the <code class="docutils literal notranslate"><span class="pre">minIndex</span></code> (inclusive) and <code class="docutils literal notranslate"><span class="pre">maxIndex</span></code> (exclusive) variables. It keeps track of the location of the window using the <code class="docutils literal notranslate"><span class="pre">leftEdge</span></code> and <code class="docutils literal notranslate"><span class="pre">rightEdge</span></code> variables, which mark the minimum and maximum azimuth of the window, respectively. The targets are stored in a sequential list called <code class="docutils literal notranslate"><span class="pre">targets</span></code>. The main loop of the algorithm begins by computing how far to advance window for a target to enter the window, and how far to advance it for a target to exit the window. The minimum of these two distances determines the next rising/falling edge of the target count graph. If a target is entering the window, <code class="docutils literal notranslate"><span class="pre">maxIndex</span></code> needs to be incremented; if one is exiting the window, <code class="docutils literal notranslate"><span class="pre">minIndex</span></code> needs to be incremented. Then, the window is advanced by the minimum distance. The target count can be computed simply by subtracting <code class="docutils literal notranslate"><span class="pre">minIndex</span></code> from <code class="docutils literal notranslate"><span class="pre">maxIndex</span></code>. The loop is done when the left edge of the window has advanced past the maximum possible azimuth; this means that all possible azimuths have been checked.</p>
<p>The full computation is interested in determining the maximum target count, the maximum tracking count, and the minimum group sparseness, so the real code has some additional bookkeeping to determine these values. However, the meat of the algorithm is contained in the code sample above.</p>
</section>
</section>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  
    <p class="logo"><a href="main_page.html">
      <img class="logo" src="../_static/sidebar_logo.png" alt="Logo"/>
    </a></p>
  

<script src="../_static/extension.js"></script>
<p>
   <ul class="Core-menu">
      <li><a href="main_page.html">Main Page</a></li>
      <li><a href="changelog/afsim_2.9.html">Changelog</a> | <a href="afsim_change_log.html">History</a></li>
      <li><a href="documents.html">Documents</a></li>
      <li><a href="security_info.html">Security Information</a></li>
      <li><a href="contact_info.html">Contact Information</a></li>
   </ul>
</p>

<br>
<hr>
<br>

<p>
   <h3>Core Apps</h3>
   <ul class="Core-menu">
     <li><a href="wsf_core.html">Main Page</a></li>
     <li><a href="wsf_reference_guide.html">Reference Guide</a></li>
     <li><a href="changelog/wsf_2.9.html">Changelog</a> | <a href="wsf_change_log.html">History</a></li>
   </ul>
</p>

<p>
   <h3>Demos</h3>
   <ul class="DEMOS-menu">
     <li><a href="changelog/demos_2.9.html">Changelog</a> | <a href="demos_change_log.html">History</a></li>
   </ul>
</p>

<p>
   <h3>Mystic</h3>
   <ul class="Mystic-menu">
     <li><a href="mystic.html">Main Page</a></li>
     <li><a href="mystic_users_guide.html">User's Guide</a></li>
     <li><a href="mystic_reference_guide.html">Reference Guide</a></li>
     <li><a href="pymystic.html">Batch Processing</a></li>
     <li><a href="changelog/mystic_2.9.html">Changelog</a> | <a href="mystic_change_log.html">History</a></li>
   </ul>
</p>

<p>
   <h3>Warlock</h3>
   <ul class="WARLOCK-menu">
     <li><a href="warlock.html">Main Page</a></li>
     <li><a href="warlock_users_guide.html">User's Guide</a></li>
     <li><a href="warlock_reference_guide.html">Reference Guide</a></li>
     <li><a href="changelog/warlock_2.9.html">Changelog</a> | <a href="warlock_change_log.html">History</a></li>
   </ul>
</p>

<p>
   <h3>Wizard</h3>
   <ul class="WIZARD-menu">
     <li><a href="wizard.html">Main Page</a></li>
     <li><a href="wizard_users_guide.html">User's Guide</a></li>
     <li><a href="wizard_reference_guide.html">Reference Guide</a></li>
     <li><a href="changelog/wizard_2.9.html">Changelog</a> | <a href="wizard_change_log.html">History</a></li>
   </ul>
</p>

<p>
   <h3>EVT Reader</h3>
   <ul class="EvtReader-menu">
     <li><a href="evtreader.html">Main Page</a></li>
   </ul>
</p>

<p>
   <h3>Mover Creator</h3>
   <ul class="MoverCreator-menu">
     <li><a href="mover_creator.html">Main Page</a></li>
     <li><a href="mc_users_guide.html">User's Guide</a></li>
     <li><a href="mc_reference_guide.html">Reference Guide</a></li>
     <li><a href="changelog/mover_creator_2.9.html">Changelog</a> | <a href="mc_change_log.html">History</a></li>
   </ul>
</p>

<br>
<hr>
<br>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/docs/WSF_SENSORS_MANAGER_FOV.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a></li>
        <li class="right" >
          <a href="../wsf-classindex.html" title="Script Class Index"
             >classes</a> |</li>
        <li class="right" >
          <a href="../wsf-commandindex.html" title="Command Index"
             >commands</a> |</li>
        <li class="right" >
          <a href="../wsf-modelindex.html" title="Model Index"
             >models</a> |</li>
        <li class="right" >
          <a href="../wsf-demoindex.html" title="Demo Index"
             >demos</a> |</li>
        <li class="right" >
          <a href="wsf_simple_coverage.html" title="WSF_SIMPLE_COVERAGE_MOE"
             >next</a> |</li>
        <li class="right" >
          <a href="WSF_SENSORS_MANAGER.html" title="WSF_SENSORS_MANAGER"
             >previous</a> |</li>
  <li>
    <img src="../_static/relbar_logo.png" alt=""
         style="vertical-align: middle; margin-top: -2px" />
  </li>
  <li>
    <a href="main_page.html">AFSIM 2.9.0 Documentation</a> &#187;
  </li>
  
        <li class="nav-item nav-item-0"><a href="../site_index.html">Site Index</a> &#187;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright Multiple, All Rights Reserved.
      Last updated on Feb 25, 2022.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>